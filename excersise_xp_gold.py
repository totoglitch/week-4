# -*- coding: utf-8 -*-
"""excersise xp gold

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hw390y4oS6_tg3V2EOYCH-TUS_KSm2Ai

Exercise 1 : Advanced Matrix Operations
Instructions
Reminder: Eigenvectors are used to understand the linear transformations of a matrix. They show the directions in which a matrix, when applied, stretches the space.

Matrix normalization is the process of adjusting the values in the matrix to a common scale, without distorting differences in the ranges of values. It’s used to bring all the variables to a uniform scale. This is particularly useful in machine learning algorithms that calculate distances between data.

Create a 5x5 matrix with random numbers and perform the following operations:
1. Calculate the eigenvalues and eigenvectors.
2. Perform matrix normalization.
"""

import numpy as np
matrix = np.random.rand(5, 5)
eigenvalues, eigenvectors = np.linalg.eig(matrix)
print("Matrix:")
matrix
print("\nEigenvalues and Eigenvectors:")
print(eigenvalues)
print(eigenvectors)
matrix_min = np.min(matrix)
matrix_max = np.max(matrix)
normalized_matrix = (matrix - matrix_min) / (matrix_max - matrix_min)

print("\nNormalized Matrix:")
normalized_matrix

"""Exercise 2 : Statistical Distribution Analysis
Instructions
Hint: To generate a dataset following a normal distribution, you can use numpy’s np.random.normal() function. For plotting its histogram, matplotlib’s plt.hist() can be used.

Generate a dataset following a normal distribution and plot its histogram. Then, calculate and interpret its skewness and kurtosis.


"""



"""Exercise 3 : Time Series Forecasting
Instructions


import numpy as np

# Generating monthly sales data as a NumPy array
monthly_sales_data = np.random.randint(100, 500, size=12)  # Random sales data for 12 months


Using a simple NumPy array representing time series data (e.g., monthly sales data), demonstrate how to forecast future data points using linear regression.


"""

monthly_sales_data = np.random.randint(100, 500, size=12)
import numpy as np
import scipy.stats as stats
from sklearn.linear_model import LinearRegression
X = np.arange(12).reshape(-1,1)
y = monthly_sales_data
model = LinearRegression()
model.fit(X, y)
print("Coefficients:", model.coef_)
print("Intercept:", model.intercept_)
future_months = np.arange(12, 15).reshape(-1,1)
future_sales_predictions = model.predict(future_months)
print("Future Sales Predictions:", future_sales_predictions)

"""Exercise 4 : Pandas Data Aggregation
Instructions


import pandas as pd

# Creating a sample Pandas DataFrame
data = {
    'Product': ['Product A', 'Product B', 'Product C', 'Product A', 'Product B'],
    'Sales': [200, 150, 300, 250, 180],
    'Month': ['January', 'February', 'March', 'April', 'May']
}
df = pd.DataFrame(data)


Using a Pandas DataFrame, demonstrate grouping and aggregation techniques to summarize the data effectively.


"""

import pandas as pd

data = {
    'Product': ['Product A', 'Product B', 'Product C', 'Product A', 'Product B'],
    'Sales': [200, 150, 300, 250, 180],
    'Month': ['January', 'February', 'March', 'April', 'May']
}
df = pd.DataFrame(data)

# Group data by 'Product' and calculate the sum of 'Sales' for each product
product_sales = df.groupby('Product')['Sales'].sum()
print("Total Sales by Product:\n", product_sales)

# Group data by 'Month' and find the average sales for each month
average_monthly_sales = df.groupby('Month')['Sales'].mean()
print("\nAverage Monthly Sales:\n", average_monthly_sales)

# Group data by both 'Product' and 'Month' and get the total sales
product_monthly_sales = df.groupby(['Product', 'Month'])['Sales'].sum()
print("\nTotal Sales by Product and Month:\n", product_monthly_sales)

"""Exercise 5 : Complex Data Visualization
Instructions
Create a multi-plot layout using Matplotlib and plot different types of graphs (e.g., line, scatter, bar) with NumPy-generated data.
"""

import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0, 10, 100)
y1 = np.sin(x)
y2 = np.cos(x)
categories = ['A', 'B', 'C', 'D']
values = np.random.randint(10, 30, size=4)
scatter_x = np.random.rand(50)
scatter_y = np.random.rand(50)


# Create a multi-plot layout (2 rows, 2 columns)
fig, axes = plt.subplots(2, 2, figsize=(10, 8))

# Plot 1: Line plot
axes[0, 0].plot(x, y1, label='sin(x)', color='blue')
axes[0, 0].plot(x, y2, label='cos(x)', color='red')
axes[0, 0].set_xlabel('X')
axes[0, 0].set_ylabel('Y')
axes[0, 0].set_title('Sine and Cosine Waves')
axes[0, 0].legend()

# Plot 2: Scatter plot
axes[0, 1].scatter(scatter_x, scatter_y, label='Scatter Data', color='green', marker='o')
axes[0, 1].set_xlabel('X')
axes[0, 1].set_ylabel('Y')
axes[0, 1].set_title('Scatter Plot')
axes[0, 1].legend()

# Plot 3: Bar plot
axes[1, 0].bar(categories, values, color=['red', 'blue', 'green', 'orange'])
axes[1, 0].set_xlabel('Categories')
axes[1, 0].set_ylabel('Values')
axes[1, 0].set_title('Bar Chart')


# Plot 4: Histogram from normalized matrix
axes[1,1].hist(normalized_matrix.flatten(), bins=10)
axes[1,1].set_xlabel('Value')
axes[1,1].set_ylabel('Frequency')
axes[1,1].set_title('Histogram of Normalized Matrix')


# Adjust layout to prevent overlapping
plt.tight_layout()
plt.show()